//Type: MUX with priority policy; Assigned name: ${name}; Assigned unique id: ${id}
module MUX_${id}
  rej_${id}[${associatedSparePortIds.size()}]: bool init false;
  queue_${id}[${associatedSparePortIds.size()}]: bool init false;
  available_${id}: bool init true;
  broken_${id}: bool init false;
  activate_${id} : [0..2] init 0;

  [f_${basicEventId}??] -> (broken_${id}'=true) & (available_${id}'=true);
  [u_${basicEventId}??] -> (broken_${id}'=false);

//Comunication from multiplexers to spare gates. The relationship is many to many. We use the naming convention <action_name>_<id_from>_<id_to>
#foreach( $associatedId in $associatedSparePortIds )
  #set( $decresedVelocityCount = $velocityCount - 1 )
  [rq_${id}_${associatedId}??] broken_${id} | !available_${id} -> (queue_${id}[${decresedVelocityCount}]'=true) & (rej_${id}[${decresedVelocityCount}]'=true);
  [rq_${id}_${associatedId}??] !broken_${id} & available_${id} -> (queue_${id}[${decresedVelocityCount}]'=true);
  [asg_${id}_${associatedId}!!] !broken_${id} & available_${id} & fsteq(queue_${id},true) == ${decresedVelocityCount} & activate_${id}==0 -> (available_${id}'=false) & (queue_${id}[${decresedVelocityCount}]'=false) & (activate_${id}' = 1);
  [rel_${id}_${associatedId}??] -> (available_${id}'=true) & (activate_${id}' = 2);
  [rj_${id}_${associatedId}!!] rej_${id}[${decresedVelocityCount}] -> (rej_${id}[${decresedVelocityCount}]'=false);
#end

  [a_${basicEventId}!!] activate_${id} == 1 -> (activate_${id}'=0);
  [d_${basicEventId}!!] activate_${id} == 2 -> (activate_${id}'=0);

endmodule

